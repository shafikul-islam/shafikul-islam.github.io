# -*- coding: utf-8 -*-
"""Time_GPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V6kPqfdJdJy_d5u2vuHDhx0TVkb3cduS
"""

pip install nixtla>=0.5.1

pip install --upgrade nixtla

from nixtla import NixtlaClient
import pandas as pd

import os

import matplotlib.pyplot as plt

# Initialize the TimeGPT client with your API key
nixtla_client = NixtlaClient(api_key="nixtla-tok-MubLPFBIrZs1ThY0EJmWM1oYrx33VWR8wiv4mh1VPLDzq97dJtsqDs9PdwenOio8KGkq2bcmHDEuH5vl")

import pandas as pd

# Updated Semiannual Data
data = {
    "ds": [
        "2000-01-01", "2000-07-01", "2001-01-01", "2001-07-01", "2002-01-01", "2002-07-01",
        "2003-01-01", "2003-07-01", "2004-01-01", "2004-07-01", "2005-01-01", "2005-07-01",
        "2006-01-01", "2006-07-01", "2007-01-01", "2007-07-01", "2008-01-01", "2008-07-01",
        "2009-01-01", "2009-07-01", "2010-01-01", "2010-07-01", "2011-01-01", "2011-07-01",
        "2012-01-01", "2012-07-01", "2013-01-01", "2013-07-01", "2014-01-01", "2014-07-01",
        "2015-01-01", "2015-07-01", "2016-01-01", "2016-07-01", "2017-01-01", "2017-07-01",
        "2018-01-01", "2018-07-01", "2019-01-01", "2019-07-01", "2020-01-01", "2020-07-01",
        "2021-01-01", "2021-07-01", "2022-01-01", "2022-07-01", "2023-01-01"
    ],
    "Cobalt_Global_Production": [
        35497.00, 36744.00, 37990.00, 38890.00, 39790.00, 41752.00, 42714.00, 45400.00,
        48085.00, 50815.00, 53546.00, 54543.00, 53540.00, 53375.00, 53210.00, 55306.00,
        57402.00, 59802.00, 62203.00, 63378.00, 79553.00, 81433.00, 82313.00, 80238.00,
        78162.00, 90970.00, 87754.00, 90970.00, 93304.00, 99480.00, 101465.00, 101070.00,
        98620.00, 106997.00, 114360.00, 117648.00, 122748.00, 128382.00, 130324.00, 127521.00,
        126321.00, 144331.00, 151459.00, 161590.00, 161224.00, 206800.00, 229300.00
    ],
    "Cobalt_Average_Price": [
        15000.00, 15000.00, 15500.00, 15500.00, 15500.00, 16000.00, 16000.00, 16000.00,
        17000.00, 18000.00, 20000.00, 20000.00, 20000.00, 22000.00, 22000.00, 22000.00,
        22000.00, 22000.00, 24000.00, 24000.00, 24000.00, 25000.00, 25000.00, 25000.00,
        24000.00, 24000.00, 25000.00, 25500.00, 25000.00, 25000.00, 25000.00, 20000.00,
        20000.00, 25000.00, 27000.00, 50000.00, 80000.00, 50000.00, 30000.00, 30000.00,
        28000.00, 40000.00, 51000.00, 40000.00, 36000.00, 30000.00, 24300.00
    ],
    "Indium_Global_Production": [
        220.00, 220.00, 220.00, 190.00, 189.20, 190.00, 180.00, 200.00,
        41.80, 41.80, 32.50, 32.00, 629.00, 630.00, 643.00, 640.00,
        627.00, 620.00, 615.00, 610.00, 643.00, 650.00, 690.00, 700.00,
        726.00, 740.00, 756.00, 780.00, 796.00, 800.00, 852.00, 800.00,
        792.00, 792.00, 792.00, 800.00, 804.00, 820.00, 854.00, 820.00,
        818.00, 850.00, 881.00, 900.00, 933.00, 950.00, 990.00
    ],
    "Indium_Global_Price": [
        100.00, 100.00, 100.00, 100.00, 100.00, 100.00, 120.00, 120.00,
        120.00, 140.00, 150.00, 150.00, 150.00, 170.00, 180.00, 190.00,
        180.00, 200.00, 200.00, 200.00, 200.00, 180.00, 200.00, 200.00,
        220.00, 230.00, 230.00, 240.00, 250.00, 270.00, 300.00, 300.00,
        300.00, 350.00, 400.00, 400.00, 410.00, 420.00, 428.61, 300.00,
        315.11, 315.00, 315.10, 400.00, 477.10, 430.00, 442.30
    ],
    "Gallium_Global_Production": [
        90.00, 85.50, 81.00, 75.50, 70.00, 84.00, 98.00, 78.00,
        59.85, 61.00, 63.00, 68.00, 72.00, 45.00, 19.00, 29.00,
        39.00, 39.00, 39.00, 38.00, 37.00, 137.00, 237.00, 275.00,
        314.00, 344.00, 374.00, 350.00, 351.00, 330.00, 326.00, 280.00,
        222.00, 310.00, 342.00, 380.00, 427.00, 380.00, 384.00, 340.00,
        358.00, 410.00, 445.00, 430.00, 412.00, 380.00, 320.00
    ],
    "Gallium_Average_Price": [
        100.00, 100.00, 100.00, 100.00, 100.00, 150.00, 150.00, 150.00,
        150.00, 150.00, 150.00, 150.00, 150.00, 175.00, 200.00, 190.00,
        180.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 180.00,
        200.00, 220.00, 250.00, 250.00, 250.00, 280.00, 300.00, 300.00,
        300.00, 300.00, 300.00, 280.00, 270.00, 330.00, 355.00, 310.00,
        298.00, 400.00, 422.70, 450.00, 510.00, 380.00, 240.00
    ],
    "EV_Market_Share": [
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.01, 0.01, 0.01, 0.07, 0.08,
        0.16, 0.18, 0.27, 0.35, 0.43, 0.55, 0.70, 0.80,
        0.89, 1.15, 1.40, 1.85, 2.30, 2.45, 2.60, 2.90,
        4.20, 4.50, 8.70, 9.50, 14.00, 16.00, 18.00
    ],
    "Lithium_Ion_Battery_Price": [
        1200.00, 1200.00, 1200.00, 1200.00, 1200.00, 1200.00, 1100.00, 1100.00,
        1100.00, 1000.00, 1000.00, 1000.00, 950.00, 950.00, 900.00, 900.00,
        750.00, 750.00, 700.00, 700.00, 800.00, 800.00, 750.00, 750.00,
        700.00, 700.00, 600.00, 550.00, 500.00, 475.00, 450.00, 425.00,
        400.00, 400.00, 350.00, 325.00, 300.00, 275.00, 250.00, 235.00,
        220.00, 210.00, 200.00, 190.00, 180.00, 140.00, 150.00
    ]
}

# Create DataFrame
df = pd.DataFrame(data)

# Convert 'ds' to datetime
df['ds'] = pd.to_datetime(df['ds'])

# Display the updated DataFrame
print(df.head())

def forecast_exogenous_variable(df, target_col, h=20):
    """
    Forecasts an exogenous variable using TimeGPT.

    Parameters:
    - df (pd.DataFrame): Historical data containing 'ds' and the target exogenous variable.
    - target_col (str): The name of the exogenous variable to forecast.
    - h (int): Forecast horizon (number of future periods).

    Returns:
    - pd.DataFrame: Forecasted values with columns ['ds', 'yhat', 'yhat_lower', 'yhat_upper'].
    """
    exog_df = df[['ds', target_col]].rename(columns={target_col: 'y'})

    # Perform the forecast with a single confidence level to simplify
    forecast = nixtla_client.forecast(
        df=exog_df,
        h=h,
        target_col='y',
        level=[90]  # Specify a single confidence level (90%)
    )

    # Inspect the forecast columns
    print(f"\nExogenous Variable Forecast Columns for '{target_col}': {list(forecast.columns)}")
    print(forecast.head())

    # Initialize renaming dictionary
    rename_dict = {}

    # Dynamically rename columns based on existing names
    for col in forecast.columns:
        if 'TimeGPT-lo-90' in col:
            rename_dict[col] = 'yhat_lower'
        elif 'TimeGPT-hi-90' in col:
            rename_dict[col] = 'yhat_upper'
        elif 'TimeGPT' == col:
            rename_dict[col] = 'yhat'

    # Apply renaming
    forecast = forecast.rename(columns=rename_dict)

    # Verify required columns are present
    required_cols = ['ds', 'yhat', 'yhat_lower', 'yhat_upper']
    missing_cols = [col for col in required_cols if col not in forecast.columns]

    if missing_cols:
        print(f"Missing columns in exogenous forecast for '{target_col}': {missing_cols}")
        # Print available columns for debugging
        print(f"Available columns: {list(forecast.columns)}")
        raise KeyError(f"The following required columns are missing in the forecast for '{target_col}': {missing_cols}")

    return forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

def forecast_element_with_exog(df, element_col, exog_cols, h=20):
    """
    Forecasts a target element using TimeGPT with exogenous variables.

    Parameters:
    - df (pd.DataFrame): Historical data containing 'ds', the target element, and exogenous variables.
    - element_col (str): The name of the target element to forecast.
    - exog_cols (list): List of exogenous variable column names.
    - h (int): Forecast horizon (number of future periods).

    Returns:
    - pd.DataFrame: Forecasted values with columns ['ds', 'yhat', 'yhat_lower', 'yhat_upper'].
    """
    # Prepare historical data with exogenous variables
    element_df = df[['ds', element_col] + exog_cols].rename(columns={element_col: 'y'})

    # Forecast each exogenous variable
    exog_fcst_list = []
    for exog in exog_cols:
        print(f"\nForecasting exogenous variable '{exog}' for target '{element_col}'...")
        fcst = forecast_exogenous_variable(df, exog, h=h)
        exog_fcst_list.append(fcst)

    # Merge all forecasted exogenous variables on 'ds'
    X_df = exog_fcst_list[0][['ds', 'yhat']].rename(columns={'yhat': exog_cols[0]})
    if len(exog_fcst_list) > 1:
        for fcst, exog in zip(exog_fcst_list[1:], exog_cols[1:]):
            X_df = X_df.merge(fcst[['ds', 'yhat']].rename(columns={'yhat': exog}), on='ds')

    print(f"\nMerged Exogenous Variables for '{element_col}':")
    print(X_df.head())

    # Perform the forecast for the target element with exogenous variables
    forecast = nixtla_client.forecast(
        df=element_df,
        X_df=X_df,
        h=h,
        level=[90]  # Specify a single confidence level (90%)
    )

    # Inspect the forecast columns
    print(f"\nElement Forecast Columns for '{element_col}': {list(forecast.columns)}")
    print(forecast.head())

    # Initialize renaming dictionary
    rename_dict = {}

    # Dynamically rename columns based on existing names
    for col in forecast.columns:
        if 'TimeGPT-lo-90' in col:
            rename_dict[col] = 'yhat_lower'
        elif 'TimeGPT-hi-90' in col:
            rename_dict[col] = 'yhat_upper'
        elif 'TimeGPT' == col:
            rename_dict[col] = 'yhat'

    # Apply renaming
    forecast = forecast.rename(columns=rename_dict)

    # Verify required columns are present
    required_cols = ['ds', 'yhat', 'yhat_lower', 'yhat_upper']
    missing_cols = [col for col in required_cols if col not in forecast.columns]

    if missing_cols:
        print(f"Missing columns in element forecast for '{element_col}': {missing_cols}")
        # Print available columns for debugging
        print(f"Available columns: {list(forecast.columns)}")
        raise KeyError(f"The following required columns are missing in the forecast for '{element_col}': {missing_cols}")

    return forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

def plot_forecast(element_df, forecast_df, title, y_label):
    """
    Plots historical data and forecasted data with confidence intervals.

    Parameters:
    - element_df (pd.DataFrame): Historical data with columns ['ds', 'y'].
    - forecast_df (pd.DataFrame): Forecast data with columns ['ds', 'yhat', 'yhat_lower', 'yhat_upper'].
    - title (str): Title of the plot.
    - y_label (str): Label for the Y-axis.
    """
    plt.figure(figsize=(12, 6))

    # Plot historical data
    plt.plot(element_df['ds'], element_df['y'], label='Historical', marker='o')

    # Plot forecasted data
    plt.plot(forecast_df['ds'], forecast_df['yhat'], label='Forecast', marker='x', color='red')

    # Plot confidence intervals
    plt.fill_between(forecast_df['ds'],
                     forecast_df['yhat_lower'],
                     forecast_df['yhat_upper'],
                     color='pink', alpha=0.3, label='Confidence Interval')

    plt.xlabel('Date')
    plt.ylabel(y_label)
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Define exogenous variables for each element
cobalt_exog = ['Cobalt_Average_Price', 'EV_Market_Share', 'Lithium_Ion_Battery_Price']
gallium_exog = ['Gallium_Average_Price', 'EV_Market_Share', 'Lithium_Ion_Battery_Price']
indium_exog = ['Indium_Global_Price', 'EV_Market_Share', 'Lithium_Ion_Battery_Price']

# Define forecast horizon (number of future periods)
forecast_horizon = 10  # e.g., 10 semiannual periods (5 years)

# Forecast Cobalt_Global_Production
print("\nForecasting Cobalt_Global_Production...")
try:
    cobalt_fcst = forecast_element_with_exog(
        df=df,
        element_col='Cobalt_Global_Production',
        exog_cols=cobalt_exog,
        h=forecast_horizon
    )
    print("\nCobalt Forecast:")
    print(cobalt_fcst.head())
except KeyError as e:
    print(e)

# Forecast Gallium_Global_Production
print("\nForecasting Gallium_Global_Production...")
try:
    gallium_fcst = forecast_element_with_exog(
        df=df,
        element_col='Gallium_Global_Production',
        exog_cols=gallium_exog,
        h=forecast_horizon
    )
    print("\nGallium Forecast:")
    print(gallium_fcst.head())
except KeyError as e:
    print(e)

# Forecast Indium_Global_Production
print("\nForecasting Indium_Global_Production...")
try:
    indium_fcst = forecast_element_with_exog(
        df=df,
        element_col='Indium_Global_Production',
        exog_cols=indium_exog,
        h=forecast_horizon
    )
    print("\nIndium Forecast:")
    print(indium_fcst.head())
except KeyError as e:
    print(e)

# Prepare historical data for Cobalt
cobalt_hist = df[['ds', 'Cobalt_Global_Production']].rename(columns={'Cobalt_Global_Production': 'y'})

print("\nPlotting Cobalt Forecast...")
plot_forecast(
    element_df=cobalt_hist,
    forecast_df=cobalt_fcst,
    title='Cobalt Global Production Forecast',
    y_label='Cobalt Global Production'
)

# Prepare historical data for Gallium
gallium_hist = df[['ds', 'Gallium_Global_Production']].rename(columns={'Gallium_Global_Production': 'y'})

print("\nPlotting Gallium Forecast...")
plot_forecast(
    element_df=gallium_hist,
    forecast_df=gallium_fcst,
    title='Gallium Global Production Forecast',
    y_label='Gallium Global Production'
)

# Prepare historical data for Indium
indium_hist = df[['ds', 'Indium_Global_Production']].rename(columns={'Indium_Global_Production': 'y'})

print("\nPlotting Indium Forecast...")
plot_forecast(
    element_df=indium_hist,
    forecast_df=indium_fcst,
    title='Indium Global Production Forecast',
    y_label='Indium Global Production'
)

# Combined Forecast Chart

# Rename forecast columns for clarity
cobalt_fcst_combined = cobalt_fcst.rename(columns={'yhat': 'Cobalt_Forecast'})
gallium_fcst_combined = gallium_fcst.rename(columns={'yhat': 'Gallium_Forecast'})
indium_fcst_combined = indium_fcst.rename(columns={'yhat': 'Indium_Forecast'})

# Merge forecasts on 'ds'
combined_forecasts = cobalt_fcst_combined[['ds', 'Cobalt_Forecast']].merge(
    gallium_fcst_combined[['ds', 'Gallium_Forecast']], on='ds'
).merge(
    indium_fcst_combined[['ds', 'Indium_Forecast']], on='ds'
)

# Plot combined forecasts with actual data
plt.figure(figsize=(14,8))

# Plot actual data
plt.plot(df['ds'], df['Cobalt_Global_Production'], label='Cobalt Actual', marker='o')
plt.plot(df['ds'], df['Gallium_Global_Production'], label='Gallium Actual', marker='o')
plt.plot(df['ds'], df['Indium_Global_Production'], label='Indium Actual', marker='o')

# Plot forecasts
plt.plot(combined_forecasts['ds'], combined_forecasts['Cobalt_Forecast'], label='Cobalt Forecast', marker='x', color='red')
plt.plot(combined_forecasts['ds'], combined_forecasts['Gallium_Forecast'], label='Gallium Forecast', marker='x', color='green')
plt.plot(combined_forecasts['ds'], combined_forecasts['Indium_Forecast'], label='Indium Forecast', marker='x', color='purple')

plt.xlabel('Date')
plt.ylabel('Global Production')
plt.title('Combined Forecast of Cobalt, Gallium, and Indium Global Production')
plt.legend()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set a professional style
sns.set(style="whitegrid")

# Combined Forecast Chart with Multiple Y-Axes
fig, ax1 = plt.subplots(figsize=(14, 8))

# Define colors
color_cobalt = 'tab:blue'
color_gallium = 'tab:green'
color_indium = 'tab:purple'

# Plot Cobalt on primary y-axis
ax1.set_xlabel('Date', fontsize=14)
ax1.set_ylabel('Cobalt Global Production (Metric Tons)', color=color_cobalt, fontsize=14)
ax1.plot(df['ds'], df['Cobalt_Global_Production'], label='Cobalt Actual', marker='o', color=color_cobalt, linewidth=2)
ax1.plot(combined_forecasts['ds'], combined_forecasts['Cobalt_Forecast'], label='Cobalt Forecast', marker='x', color=color_cobalt, linestyle='--', linewidth=2)
ax1.tick_params(axis='y', labelcolor=color_cobalt, labelsize=12)
ax1.tick_params(axis='x', labelsize=12)

# Create a secondary y-axis for Gallium and Indium
ax2 = ax1.twinx()

ax2.set_ylabel('Gallium & Indium Global Production (Metric Tons)', color=color_gallium, fontsize=14)
ax2.plot(df['ds'], df['Gallium_Global_Production'], label='Gallium Actual', marker='o', color=color_gallium, linewidth=2)
ax2.plot(combined_forecasts['ds'], combined_forecasts['Gallium_Forecast'], label='Gallium Forecast', marker='x', color=color_gallium, linestyle='--', linewidth=2)
ax2.plot(df['ds'], df['Indium_Global_Production'], label='Indium Actual', marker='o', color=color_indium, linewidth=2)
ax2.plot(combined_forecasts['ds'], combined_forecasts['Indium_Forecast'], label='Indium Forecast', marker='x', color=color_indium, linestyle='--', linewidth=2)
ax2.tick_params(axis='y', labelcolor=color_gallium, labelsize=12)

# Combine legends from both axes
lines_1, labels_1 = ax1.get_legend_handles_labels()
lines_2, labels_2 = ax2.get_legend_handles_labels()
ax1.legend(lines_1 + lines_2, labels_1 + labels_2, loc='upper left', fontsize=12)

# Add title
plt.title('Combined Forecast of Cobalt, Gallium, and Indium Global Production', fontsize=16)

# Adjust layout for better spacing
fig.tight_layout()

# Show grid
ax1.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)

# Save the figure in high resolution
plt.savefig('combined_forecast.png', dpi=300)

# Display the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set a professional style
sns.set(style="whitegrid")

# Create subplots
fig, axes = plt.subplots(3, 1, figsize=(14, 18), sharex=True)

# Define colors
colors = {'Actual': 'tab:blue', 'Forecast': 'tab:red'}

# Plot Cobalt
axes[0].plot(df['ds'], df['Cobalt_Global_Production'], label='Cobalt Actual', marker='o', color=colors['Actual'], linewidth=2)
axes[0].plot(combined_forecasts['ds'], combined_forecasts['Cobalt_Forecast'], label='Cobalt Forecast', marker='x', color=colors['Forecast'], linestyle='--', linewidth=2)
axes[0].set_ylabel('Cobalt Global Production (Metric Tons)', fontsize=14)
axes[0].legend(fontsize=12)
axes[0].tick_params(axis='y', labelsize=12)

# Plot Gallium
axes[1].plot(df['ds'], df['Gallium_Global_Production'], label='Gallium Actual', marker='o', color='tab:green', linewidth=2)
axes[1].plot(combined_forecasts['ds'], combined_forecasts['Gallium_Forecast'], label='Gallium Forecast', marker='x', color='tab:orange', linestyle='--', linewidth=2)
axes[1].set_ylabel('Gallium Global Production (Metric Tons)', fontsize=14)
axes[1].legend(fontsize=12)
axes[1].tick_params(axis='y', labelsize=12)

# Plot Indium
axes[2].plot(df['ds'], df['Indium_Global_Production'], label='Indium Actual', marker='o', color='tab:purple', linewidth=2)
axes[2].plot(combined_forecasts['ds'], combined_forecasts['Indium_Forecast'], label='Indium Forecast', marker='x', color='tab:cyan', linestyle='--', linewidth=2)
axes[2].set_ylabel('Indium Global Production (Metric Tons)', fontsize=14)
axes[2].set_xlabel('Date', fontsize=14)
axes[2].legend(fontsize=12)
axes[2].tick_params(axis='y', labelsize=12)
axes[2].tick_params(axis='x', labelsize=12)

# Add title
fig.suptitle('Forecast of Cobalt, Gallium, and Indium Global Production', fontsize=16)

# Adjust layout for better spacing
fig.tight_layout(rect=[0, 0.03, 1, 0.97])

# Save the figure in high resolution
plt.savefig('separate_forecasts.png', dpi=300)

# Display the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates

# Apply seaborn style
sns.set(style="whitegrid")

# Set global font sizes and line widths
plt.rcParams.update({
    'font.size': 14,
    'axes.labelsize': 16,
    'axes.titlesize': 18,
    'legend.fontsize': 12,
    'lines.linewidth': 2,
    'lines.markersize': 8
})

# Combined Forecast Chart with Multiple Y-Axes
fig, ax1 = plt.subplots(figsize=(14, 8))

# Define colors
color_cobalt = 'tab:blue'
color_gallium = 'tab:green'
color_indium = 'tab:purple'

# Plot Cobalt on primary y-axis
ax1.set_xlabel('Date', fontsize=16)
ax1.set_ylabel('Cobalt Global Production (Metric Tons)', color=color_cobalt, fontsize=16)
ax1.plot(df['ds'], df['Cobalt_Global_Production'], label='Cobalt Actual', marker='o', color=color_cobalt, linewidth=2)
ax1.plot(combined_forecasts['ds'], combined_forecasts['Cobalt_Forecast'], label='Cobalt Forecast', marker='x', color=color_cobalt, linestyle='--', linewidth=2)
ax1.tick_params(axis='y', labelcolor=color_cobalt, labelsize=14)
ax1.tick_params(axis='x', labelsize=14)

# Format x-axis dates
ax1.xaxis.set_major_locator(mdates.YearLocator())
ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.xticks(rotation=45)

# Create a secondary y-axis for Gallium and Indium
ax2 = ax1.twinx()

ax2.set_ylabel('Gallium & Indium Global Production (Metric Tons)', color=color_gallium, fontsize=16)
ax2.plot(df['ds'], df['Gallium_Global_Production'], label='Gallium Actual', marker='o', color=color_gallium, linewidth=2)
ax2.plot(combined_forecasts['ds'], combined_forecasts['Gallium_Forecast'], label='Gallium Forecast', marker='x', color=color_gallium, linestyle='--', linewidth=2)
ax2.plot(df['ds'], df['Indium_Global_Production'], label='Indium Actual', marker='o', color=color_indium, linewidth=2)
ax2.plot(combined_forecasts['ds'], combined_forecasts['Indium_Forecast'], label='Indium Forecast', marker='x', color=color_indium, linestyle='--', linewidth=2)
ax2.tick_params(axis='y', labelcolor=color_gallium, labelsize=14)

# Combine legends from both axes
lines_1, labels_1 = ax1.get_legend_handles_labels()
lines_2, labels_2 = ax2.get_legend_handles_labels()
ax1.legend(lines_1 + lines_2, labels_1 + labels_2, loc='upper left', fontsize=12)

# Add title
plt.title('Combined Forecast of Cobalt, Gallium, and Indium Global Production', fontsize=18)

# Adjust layout for better spacing
fig.tight_layout()

# Add gridlines
ax1.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)

# Save the figure in high resolution
plt.savefig('combined_forecast_enhanced.png', dpi=300)

# Display the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates

# Apply seaborn style
sns.set(style="whitegrid")

# Set global font sizes and line widths
plt.rcParams.update({
    'font.size': 14,
    'axes.labelsize': 16,
    'axes.titlesize': 18,
    'legend.fontsize': 12,
    'lines.linewidth': 2,
    'lines.markersize': 8
})

# Create subplots
fig, axes = plt.subplots(3, 1, figsize=(14, 18), sharex=True)

# Define color palette
colors = sns.color_palette("tab10")

# Plot Cobalt
axes[0].plot(df['ds'], df['Cobalt_Global_Production'], label='Cobalt Actual', marker='o', color=colors[0], linewidth=2)
axes[0].plot(combined_forecasts['ds'], combined_forecasts['Cobalt_Forecast'], label='Cobalt Forecast', marker='x', color=colors[1], linestyle='--', linewidth=2)
axes[0].set_ylabel('Cobalt Global Production (Metric Tons)', fontsize=16)
axes[0].legend(loc='upper left', fontsize=12)
axes[0].tick_params(axis='y', labelsize=14)

# Plot Gallium
axes[1].plot(df['ds'], df['Gallium_Global_Production'], label='Gallium Actual', marker='o', color=colors[2], linewidth=2)
axes[1].plot(combined_forecasts['ds'], combined_forecasts['Gallium_Forecast'], label='Gallium Forecast', marker='x', color=colors[3], linestyle='--', linewidth=2)
axes[1].set_ylabel('Gallium Global Production (Metric Tons)', fontsize=16)
axes[1].legend(loc='upper left', fontsize=12)
axes[1].tick_params(axis='y', labelsize=14)

# Plot Indium
axes[2].plot(df['ds'], df['Indium_Global_Production'], label='Indium Actual', marker='o', color=colors[4], linewidth=2)
axes[2].plot(combined_forecasts['ds'], combined_forecasts['Indium_Forecast'], label='Indium Forecast', marker='x', color=colors[5], linestyle='--', linewidth=2)
axes[2].set_ylabel('Indium Global Production (Metric Tons)', fontsize=16)
axes[2].set_xlabel('Date', fontsize=16)
axes[2].legend(loc='upper left', fontsize=12)
axes[2].tick_params(axis='y', labelsize=14)

# Format x-axis dates
axes[2].xaxis.set_major_locator(mdates.YearLocator())
axes[2].xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.xticks(rotation=45)

# Add title
fig.suptitle('Forecast of Cobalt, Gallium, and Indium Global Production', fontsize=20)

# Adjust layout for better spacing
fig.tight_layout(rect=[0, 0.03, 1, 0.97])

# Save the figure in high resolution
plt.savefig('separate_forecasts_enhanced.png', dpi=300)

# Display the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates

# Set a clean, plain white style
sns.set(style="white")  # Changed from 'whitegrid' to 'white' for minimal grid lines

# Update global plot parameters for smaller text sizes and compact figures
plt.rcParams.update({
    'font.size': 10,           # Global font size
    'axes.labelsize': 12,      # Axes labels
    'axes.titlesize': 14,      # Axes titles
    'legend.fontsize': 10,     # Legend text
    'lines.linewidth': 1.5,    # Line width
    'lines.markersize': 5,     # Marker size
    'figure.figsize': (8, 4)   # Default figure size (width, height) in inches
})

def plot_element_forecast(df, fcst_df, element_name, element_label, colors, filename):
    """
    Plots the actual and forecasted global production for a given element.

    Parameters:
    - df (DataFrame): Original DataFrame with actual data.
    - fcst_df (DataFrame): Forecast DataFrame for the element.
    - element_name (str): Column name for the element's actual production in df.
    - element_label (str): Label for the Y-axis.
    - colors (dict): Dictionary containing colors for actual data, forecast, and confidence intervals.
    - filename (str): Filename to save the plot.
    """
    plt.figure(figsize=(8, 4))  # Reduced width

    # Plot actual data
    plt.plot(df['ds'], df[element_name], label='Actual', marker='o', color=colors['Actual'])

    # Plot forecasted data
    plt.plot(fcst_df['ds'], fcst_df['yhat'], label='Forecast', marker='x', color=colors['Forecast'], linestyle='--')

    # Shade confidence intervals
    plt.fill_between(fcst_df['ds'],
                     fcst_df['yhat_lower'],
                     fcst_df['yhat_upper'],
                     color=colors['Confidence'], alpha=0.3, label='Confidence Interval')

    # Set labels and title
    plt.ylabel(element_label, fontsize=12)
    plt.title(f"{element_label} Forecast", fontsize=14)

    # Format y-axis numbers with commas
    plt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

    # Format x-axis dates
    plt.gca().xaxis.set_major_locator(mdates.YearLocator())
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
    plt.xticks(rotation=45, fontsize=10)

    # Add legend
    plt.legend(loc='upper left', fontsize=10)

    # Enable minimal grid lines
    plt.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.5)

    # Tight layout for better spacing
    plt.tight_layout()

    # Save the figure in high resolution
    plt.savefig(filename, dpi=300, bbox_inches='tight')

    # Display the plot
    plt.show()

# Define color palettes for each element
cobalt_colors = {
    'Actual': 'tab:blue',
    'Forecast': 'tab:red',
    'Confidence': 'lightcoral'
}

gallium_colors = {
    'Actual': 'tab:green',
    'Forecast': 'tab:orange',
    'Confidence': 'lightgreen'
}

indium_colors = {
    'Actual': 'tab:purple',
    'Forecast': 'tab:brown',
    'Confidence': 'plum'
}

# Plot Cobalt Forecast
plot_element_forecast(
    df=df,
    fcst_df=cobalt_fcst,
    element_name='Cobalt_Global_Production',
    element_label='Cobalt Global Production (Metric Tons)',
    colors=cobalt_colors,
    filename='cobalt_forecast.png'
)

# Plot Gallium Forecast
plot_element_forecast(
    df=df,
    fcst_df=gallium_fcst,
    element_name='Gallium_Global_Production',
    element_label='Gallium Global Production (Metric Tons)',
    colors=gallium_colors,
    filename='gallium_forecast.png'
)

# Plot Indium Forecast
plot_element_forecast(
    df=df,
    fcst_df=indium_fcst,
    element_name='Indium_Global_Production',
    element_label='Indium Global Production (Metric Tons)',
    colors=indium_colors,
    filename='indium_forecast.png'
)

